### Real MySQL 8.0 책을 읽으며 정리한 내용과 나의 생각 정리

#### *(?)이 표시된 것은 나의 생각*

### 현재까지의 한 줄 요약
다양한 대응 방법을 익혀 트래픽량과 서비스의 종류에 따라 적절히 대응할 수 있어야 하는 방법들을 익히는 느낌(?)

### 현재까지의 메모리에 대한 나의 생각 한 줄 요약
MySQL에서 기본으로 사용되는 InnoDB엔진의 버퍼 풀 공간에 캐싱될 수 있는 데이터의 양이 메모리에 따라 다르므로, 메모리에 모든 데이터가 캐싱된다면 당연히 캐싱되어있던 데이터를 사용자에게 빨리 돌려줌으로 메모리가 중요한 것이 아닐까(?)

# * 스토리지 엔진
### MyISAM 엔진
#### - 키 캐시(인덱스 캐싱)
#### - 읽기, 쓰기를 포그라운드 스레드가 처리
#### - 메타 데이터를 별도의 파일에 저장(.sdi 확장자명의 파일)
#### - 클러스터링 키 미지원

### InnoDB엔진
#### - 버퍼 풀(테이블 및 인덱스 데이터를 캐싱)
#### - 읽기만 포그라운드 스레드가 처리, 쓰기는 백그라운드 스레드가 처리
  * 이 장점으로 인해 버퍼링(지연)처리가 가능하여 동시 작업이 가능할 듯(?) (삽입, 변경, 삭제들을 모아서 한 번에 처리하는 듯) 
#### - 메타 데이터를 DB에 저장
#### - 클러스터링 키 지원, 프라이머리 키 값의 순서대로 디스크에 저장된다는 뜻
  * 데이터를 서칭하는 과정이 좀 더 빠르게 될 수 있는 듯(?)

# * 메모리 구조
### 글로벌 메모리 영역
 * 무조건적으로 사용되야하는 데이터들이다보니 항상 메모리를 할당하여 활용하는 듯(?)
#### - InnoDB 버퍼 풀
#### - MyISAM 키 캐시
#### - 바이너리 로그 버퍼
#### - 리두 로그 버프
#### - 테이블 캐시

### 세션(커넥션,로컬) 메모리 영역
 * 필요할 때만 사용하면 되는 데이터들이다보니 항상 메모리를 할당하진 않는 듯(?)
#### - 조인 버퍼
#### - 정렬(sort) 버프
#### - 네트워크 버퍼
#### - 리드 버프

# * 쿼리 캐시
#### 수많은 버그의 원인으로 지목되어 MySQL 8.0이상부터는 삭제된 기능
  * 하지만 데이터 변경이 없고 읽기만 하는 전자책같은 서비스에서는 최고의 효율을 보일 듯(?)

# * 5.7버전과 8.0버전의 차이점
### 5.7버전
#### 메타 데이터를 파일 기반으로 생성 및 변경하기 때문에 비정상적으로 종료되면 테이블이 깨질 수 있음
  * 작업 도중 멈춤으로 인해 데이터의 잔해가 남는 듯(?)

### 8.0버전
#### 메타 데이터를 InnoDB의 테이블에 저장함으로 비정상적으로 종료되어도 테이블이 보존됨(완전한 실패 또는 성공으로 구분)
#### mysql DB에 mysql.ibd라는 이름의 테이블 스페이스에 저장

# * 언두 영역
#### 업데이트되기 전의 데이터를 저장하고 있는 장소
#### 데이터가 커밋된다고해서 즉시 삭제되는 것은 아니고, 필요로 하는 트랙잭션이 존재하지 않을 때 삭제됨.
  * 트랙잭션이 엮인 상태가 쌓이게 되면 언두영역에 계속 데이터가 묶이게 됨으로 MySQL서버가 느려지는 듯(?)
  * 따라서, 계속해서 필요한 데이터가 아니라면 언두영역에서 삭제되도록 해주는 것이 성능 향상에 도움이 될 듯(?)

# * 바이너리 로그
#### 데이터 변경사항들에 대한 정보를 포함하는 로그 파일의 세트
  * 만약 DB에 문제가 생긴다면 백업 파일과 바이너리 로그를 활용하여 로그의 마지막 시점까지의 데이터를 복구할 수 있는 듯(?)

# * 레코드 버퍼
#### 각 로컬 세션에서 테이블의 레코드를 읽고 쓸 때 버퍼로 사용하는 공간, 별도의 공간 설정이 불가하고 전체 커넥션 개수와 각 커넥션에서 읽고 쓰는 테이블의 개수에 따라 결정

# * InnoDB 버퍼 풀
#### 테이블 및 인덱스 데이터를 캐싱해서 자주 사용된 데이터를 사용자가 빠르게 돌려받을 수 있도록 도와줌.
  * MRU와 LRU라는 많이 사용된 데이터를 캐싱하는 공간과 최근 사용된 데이터를 캐싱하는 공간 개념이 있는 것 같은데, LRU에 존재하면서 사용자에게 또 요청이 들어오게되면 MRU로 승급하고 캐싱된 데이터가 자주 읽히지 않는다면 aging이 많아지면서 삭제된다는 원리인 것 같다. 단순하게 최근 조회된 글과 많이 조회된 글같은 개념으로 생각하면 될 듯(?)
#### 읽기 데이터가 아닌 쓰기 데이터도 캐싱됨
  * 플러시 리스트라는 공간에 쌓이게 되는 것 같은데, 오래전에 변경된 더티 페이지(데이터)부터 차례대로 디스크에 동기화를 해주는 듯(?), 아마 이 플러시 리스트라는 공간덕에 버퍼링(지연)처리를 하여 한 번에 여러가지 작업들을 모아서 처리하는게 아닐까 추측 중

# * MySQL서버에서의 HDD와 SSD의 차이점
#### HDD의 경우 디스크 읽고 쓰기가 매우 고비용의 작업이지만 SSD는 그렇지 않음. 만약 데이터 저장을 HDD로 하게된다면 innodb_flush_neighbors 시스템 변수를 조절하여 더티 페이지를 한 번에 묶어서 기록하도록 변경해줘야함.

